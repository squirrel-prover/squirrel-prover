include Core.

abstract p : bool.
abstract q : bool.
abstract a : message.
abstract b : message.

axiom [any] foo : p => a = b.

(* The same condition `p` is shared by both occurrences of the 
   rewritten instance. Hence `p` can be assumed when proving the 
   sub-goals generated by the rewrite. *)
lemma [any] _ : < if p then a, if p then a > = < if p then b, if p then b >.
Proof.
  by rewrite foo.
Qed.  

(* `p` is **not** shared by both occurrences (we have `q` on the right), 
   we check that `p` is droppted. *)
lemma [any] _ : < if p then a, if q then a > = < if p then b, if q then b >.
Proof.
  checkfail by rewrite foo exn GoalNotClosed.
Abort.

(*------------------------------------------------------------------*)
(* More complex scenarios checking the same property. *)

abstract r : bool.

lemma [any] _ :
   < if p then if q then a, if p then if r then a > = 
   < if p then if q then a, if p then if r then a >.
Proof.
  by rewrite foo.
Qed.  


axiom [any] fooQ : q => a = b.

lemma [any] _ :
   < if p then if q then a, if p then if r then a > = 
   < if p then if q then a, if p then if r then a >.
Proof.
  checkfail by rewrite fooQ exn GoalNotClosed.
Abort.


axiom [any] fooR : q => a = b.

lemma [any] _ :
   < if p then if q then a, if p then if r then a > = 
   < if p then if q then a, if p then if r then a >.
Proof.
  checkfail by rewrite fooR exn GoalNotClosed.
Abort.
