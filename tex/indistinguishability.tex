% Move to macros.tex
\newcommand{\lreach}[1]{\textsf{l-reach}(#1)}
\newcommand{\rreach}[1]{\textsf{r-reach}(#1)}
\newcommand{\phifresh}[3]{\textsf{n-fresh}_{#1}(#2; #3)}
\newcommand{\phihfresh}[4]{\textsf{h-fresh}_{#1}^{#2}(#3; #4)}

\section{Indistinguishability}

\newcommand{\pair}[1]{\langle #1 \rangle}

% We now define indistinguishability of processes, and how we could verify it.
% We make a distinction between symbolic and observable traces:
% symbolic ones are sequences of action names as in \cref{def:trace},
% while observable traces are sequences of pairs $\pair{c_i,c_o}$.
% Intuitively, such a pair describes the input and output channels of an
% action; several actions might have the same input and output channels.
% We write $A : \pair{c_i,c_o}$ when action $A$ inputs on channel $c_i$ and
% outputs on channel $c_o$.

% For convenience, we talk of processes, though in reality the definitions
% deal with abstract systems described by sets of actions.

\newcommand{\fold}{\mathsf{fold}}

% \begin{definition}
%   Given an observable trace $t$ and a process $P$,
%   we define $\fold(P,t)$ as the frame describing all possible
%   executions of $P$ along $t$:
%   \begin{eqnarray*}
%     \fold(P,\epsilon) &=& \epsilon \\
%     \fold(P,(c_i,c_o).t') &=&
%     \mathsf{if}_{A:(c_i,c_o)}
%     \ldots
%   \end{eqnarray*}
% \end{definition}

% \begin{definition}
%   Two processes $P$ and $Q$ are indistinguishable when,
%   for all observable traces $t$,
%   for all computational model $\Mo$,
%   we have
%   $\Mo \models \fold(P,t) \sim \fold(Q,t)$.
%   This itself means that no attacker can distinguish,
%   with non-negligible probability, between the left- and right-hand sides.
% \end{definition}

% This notion of equivalence should coincide with the usual computational
% indistinguishability for bounded processes. In the unbounded case, it
% is restrictive to quantify on traces in this way
% and ask for indistinguishability only for each trace.

\begin{definition}
  A meta-logic equivalence formula is an element of the form $\pvec{u} \sim \pvec{v}$, where $\pvec{u}$ and $\pvec{v}$ are two vectors of terms of the meta-logic of the same length.
\end{definition}

\begin{definition}
  Two protocols $\calp_1 = (\calp_{1,\cala},\leq_1)$ and $\calp_2 = (\calp_{2,\cala}, \leq_2)$, defined over the same signature, are compatible if
  \begin{itemize}
  \item   the set of action names of $\calp_{1,\cala}$ is equal to the set of action names of  $\calp_{2,\cala}$;
    \item  for any action names $\sfa,\sfa'$ in  $\calp_{1,\cala}$, we have that $ \sfa \leq_1 \sfa' \Leftrightarrow \sfa \leq_2 \sfa'$.
  \end{itemize}

\end{definition}

From this Definition, the following Lemma instantly follows.
\begin{lemma}
  If $\calp_1$ and $\calp_2$ are compatible then they have the same trace models.
\end{lemma}

% \begin{definition}
%   Let $\calp_1$ and $\calp_2$ be two compatible protocols, and
%   $\pvec{u} \sim \pvec{v}$ be a meta-logic equivalence formula.
% Then, for every $\calp_1$-trace model $\TM$, computational model $\Mo$ and interpretation~$\sigma$:
%   \begin{align*}
%     \TM, \Mo, \sigma \models_{\calp_1,\calp_2}
%     \pvec{u} \sim \pvec{v}
%     &&\text{ iff }&&
%     \Mo, \sigma \models
%     \interp{\pvec{u}}{\TM}{\calp_1} \sim \interp{\pvec{v}}{\TM}{\calp_2}
%   \end{align*}
%   Moreover, we say that $\pvec{u} \sim \pvec{v}$ is $(\calp_1,\calp_2)$-valid if $\TM, \Mo, \sigma \models_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}$ for every $\TM$, $\Mo$, $\sigma$.

%   Finally, for any set of meta-formulas $S$, $S \models \pvec{u} \sim \pvec{v}$ if for every $\TM$, $\Mo$, $\sigma$ such that $\TM, \Mo, \sigma \models_{\calp_1,\calp_2} S$, we have $\TM, \Mo, \sigma \models_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}$.
% \end{definition}

\begin{definition}
  Let $\calp_1$ and $\calp_2$ be two compatible protocols, and
  $\pvec{u} \sim \pvec{v}$ be a meta-logic equivalence formula. \stefcolor{Let
  $\TM$ be a $\calp_1$-trace model, $\Mo$ a computational model, and
  $\sigma$ an interpretation. We write  $\TM, \Mo, \sigma \models_{\calp_1,\calp_2}
    \pvec{u} \sim \pvec{v}$ when
$\Mo, \sigma \models
    \interp{\pvec{u}}{\TM}{\calp_1} \sim
    \interp{\pvec{v}}{\TM}{\calp_2}$.}
 We say that $\pvec{u} \sim \pvec{v}$ is $(\calp_1,\calp_2)$-valid if $\TM, \Mo, \sigma \models_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}$ for any $\TM$, $\Mo$, $\sigma$.
\end{definition}

\stef{Est-ce que ce dernier point dans la def est utilisé ? Si oui,
  ecrire quelquechose comme when  $\calp_1$ and $\calp_2$ are clear
  from the context. Plus bas, on parle de $S \Rightarrow u \sim
  v$ valid et je me rends compte en fait que cette derniere notion
  n'est pas definie mais c'est justement ce Finally. Exact ?}

Remark that in the Tool, rather than asking the user to input a pair of protocol, he must specify a bi-protocol. From a bi-protocol, it is straightforward to obtain the corresponding pair of protocol through projection, and a bi-protocol is by essence a pair of two compatible protocols.


Now that we can interpret equivalence for pairs of protocol, we can now define the notion of diff-equivalence, such that no attacker can distinguish between the two protocols.

\begin{definition}
  \label{def:process-equiv}
  A pair of compatible protocols $\calp_1,\calp_2$ is diff-equivalent when,
  for any $\calp$-trace model $\TM$, the formula $\mframe@\tau  \sim \mframe@\tau$ is $(\calp_1,\calp_2)$-valid.
\end{definition}

As the $\tau$ is not quantified, the previous formula is equivalent to the fact that \[
    \dand_{v\in D_\XT}
    \interp{\mframe@\tau}{\TM[\tau\mapsto v]}{\calp_1}
    \sim
    \interp{\mframe@\tau}{\TM[\tau \mapsto v]}{\calp_2}
  \]
  holds for all trace model in the base logic.  for any trace model.  Note that
  we can not explicitly add the quantification since it is not allowed by our
  notion of meta-logic equivalence formula.  This means that for any possible
  trace, and any possible timestamp in this trace, the sequence of outputs of
  the messages and the executability of the trace up to this point must be
  indistinguishable. Our indistinguishability, as it is interpreted in the CCSA
  model, is computationally sounds. It thus corresponds to the classical notion
  of computational indistinguishability.

Note that this equivalence cannot hold if there exists a trace whose probability
of execution significantly differs between the two projections of the
bi-protocol. Hence this imposes a form of synchronization on the execution of
conditionals on the two sides of bi-protocoles. This stems from the fact that we
consider protocols as pair of visible actions, where the attacker can know
whether an action succeeded or failed.


% \newcommand{\In}{\mathsf{in}}
% \newcommand{\Out}{\mathsf{out}}

% \begin{example}
%   Consider the bi-protocol
%   $\In(c,x).\myif x=\diff{0}{1} \mythen \Out(c,n) \myelse \Out(c,m)$
%   where $n$ and $m$ are arbitrary, possibly equal names.
%   Its two projections are indistinguishable, but the
%   bi-protocol is not diff-equivalent.
%   \adrien{I do not agree. If you write the process using actions (as we do), then it is equivalent. When you are translating from the pi-process to an representation using actions, you cannot change the visible actions (or this is not a sound translation).}
%   Indeed we have
%   $\myif g()=0 \mythen \Out(c,n) \not\sim
%   \myif g()=1 \mythen \Out(c,m)$: the attacker can simply choose
%   $g()=0$ to distinguish the two sides.
%   Our bi-protocol can however easily be
%   rewritten into a diff-equivalent process, e.g. by pushing the conditional
%   inside the output.

%   If we modify our bi-protocol into
%   $\In(c,x).\myif x=\diff{0}{1} \mythen \Out(c,n) \myelse \Out(c,0)$
%   then the two projections become distinguishable.
%   The attack is obtained with an execution
%   where one process outputs a name while the other outputs $0$. Such
%   desynchronized executions are not taken into account with diff-equivalence,
%   but diff-equivalence still fails due to the desynchronized condition,
%   as before.
% \end{example}

% In the next examples, we omit the $\myelse$ branch when it consists of a null
% process. In these examples, there is a coincidence between diff-equivalence
% and indistinguishability, because observable actions coincide with symbolic
% actions.

% \begin{example} \label{ex:negl}
%   Consider the bi-protocol
%   $\In(c,x).\myif x=\diff{n}{m} \mythen \Out(c,\ok)$.
%   It is diff-equivalent, and its projections are
%   indistinguishable as expected.
%   In the bi-protocol, the condition $x=\diff{n}{m}$ does not pass
%   with the same inputs on the left and right, but it passes with
%   the same negligible probability.
% \end{example}

% \begin{example} \label{ex:sync}
%   Consider
%   $\In(c,x).\myif x=(\diff{n}{m})_0 \mythen \Out(c,n)$
%   where $(t)_0$ denotes the first bit of $t$.
%   This bi-protocol is not diff-equivalent because
%   $\myif x=(n)_0 \mythen n \not\sim \myif x=(m)_0 \mythen n$, and
%   the two projections are distinguishable for the same
%   reason: the attacker sends $0$;
%   on the left he receives with probability $1\over 2$ a bitstring whose
%   first bit is $0$;
%   on the right process he receives with probably only $1\over 4$
%   a bitstring whose last bit is $0$.
%   If we change $\Out(c,n)$ into $\Out(c,\ok)$,
%   we have indistinguishable processes and diff-equivalence holds.
% \end{example}

% \begin{example} \label{ex:problem}
%   Consider $\Out(c,\diff{n}{m}).
%   \In(c,x).
%   \myif x=\diff{n}{m} \mythen \Out(c,\ok)$.
%   The projections are observationally equivalent and diff-equivalence
%   holds -- in fact they are $\alpha$-equivalent.
% \end{example}


\subsection{Reasoning about equivalences}

We extend our sequent calculus with rules to prove the equivalence formulas of the meta-logic.

\begin{definition}
  Let $\calp_1,\calp_2$ be compatible protocols. An equivalence sequent $\Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}$ comprises a set of hypotheses $\Gamma$ and a goal $\pvec{u} \sim \pvec{v}$, where $\Gamma$ and $\pvec{u} \sim \pvec{v}$ are all equivalence formulas of the meta-logic.
x
The sequent  $\Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}$ is valid if for all $\TM$, $\Mo$, $\sigma$ such that $\TM, \Mo, \sigma \models_{\calp_1,\calp_2} \psi$ for all $\psi \in \Gamma$, we have that $\TM,\Mo,\sigma \models_{\calp_1,\calp_2}  \pvec{u} \sim \pvec{v}$.
\end{definition}

\begin{lemma}
  A pair of compatible protocols $\calp_1,\calp_2$ is diff-equivalent if and only if
  \[
    \mframe@\pre(\tau) \sim \mframe@\pre(\tau)
    \vdash_{\calp_1,\calp_2}
    \mframe@\tau \sim \mframe@\tau
  \]
\end{lemma}
\begin{proof}
  Let $\TM$ and $\Mo$ be a trace and a computational model. We assume that the sequent is valid, and must prove that for all $v \in D_\XT$, $\TM\{ \tau \mapsto v\} ,\Mo \models_{P_1,P_2}     \mframe@\tau \sim \mframe@\tau$.

  We reason by induction over $v \in D_\XT$, which is a completely ordered set with $\pre$ as a predecessor function, and $\tinit$ as the minimal value.\\

  \underline{Case $v = \tinit$} In this case, $\interp{\mframe@\tau}{\TM\{ \tau \mapsto v\} }{P_1} = \interp{\mframe@\tau}{\TM\{ \tau \mapsto v\} }{P_2} = 0$, and it trivially holds that $\TM\{ \tau \mapsto \tinit\} ,\Mo \models_{P_1,P_2}     \mframe@\tau \sim \mframe@\tau$.\\

  \underline{Case $v \in D_\XT \setminus \{\tinit\}$} By induction hypothesis, we have that $\TM\{ \tau \mapsto \pre(v)\} ,\Mo \models_{P_1,P_2}  \mframe@\tau \sim \mframe@\tau$. Thus, we have that  $\TM\{ \tau \mapsto v\} ,\Mo \models_{P_1,P_2}   \mframe@\pre{\tau} \sim \mframe@\pre{\tau}$ which is the premisse of the sequent. The conclusion of the sequent then holds, i.e.~ $\TM\{ \tau \mapsto v\} ,\Mo \models_{P_1,P_2}   \mframe@\tau \sim \mframe@\tau$. This concludes the proof.
\end{proof}

% \begin{lemma}
%   A bi-protocol is diff-equivalent if and only if,
%   \[ \emptyset \vdash  \mframe^L@\tau \sim \mframe^R@\tau\]
%   Equivalently, is it diff-equivalent if and only if:
%   \[\mframe^L@\pre(\tau) \sim \mframe^R@\pre(\tau) \vdash \mframe^L@\tau \sim \mframe^R@\tau\]
% \end{lemma}
% \begin{proof}
%   We prove the first equivalence, which is essentially an unfolding of definitions.
%   \[
%     \begin{array}{l@{~}l}
%       $P$\text{ is diff-equivalent} & \Leftrightarrow \text{for all } \TM,\ \stackrel{.}{\wedge}_{v\in D_\XT} (\mframe@\tau^L)^{\TM[\tau\mapsto v]} \sim (\mframe@\tau^R)^{\TM[\tau \mapsto v]}\text{ is valid}\\
%       & \Leftrightarrow \text{for all } \TM\text{ and } v\in D_\XT,\ (\mframe@\tau^L)^{\TM[\tau\mapsto v]} \sim (\mframe@\tau^R)^{\TM[\tau \mapsto v]}\text{ is valid}\\
%       & \Leftrightarrow \text{for all } \TM\text{ and } v\in D_\XT,\ \true \stackrel{.}{\Rightarrow} (\mframe@\tau^L)^{\TM[\tau\mapsto v]} \sim (\mframe@\tau^R)^{\TM[\tau \mapsto v]}\text{ is valid}\\
%       & \Leftrightarrow  \emptyset \vdash  \mframe^L@\tau \sim \mframe@\tau^R\text{ is valid}\\

%     \end{array}
%   \]

%   The second equivalence is a direct induction on the length of the traces.
% \end{proof}

We provide in \cref{fig:lk-ind} a set of rules for equivalence sequent. These rules are independent of the protocoles $\calp_1,\calp_2$. Note that:
\begin{itemize}
\item the rule $\textsc{Sym}$ swaps the two protocols.
\item the $\textsc{Refl}$ rule checks that the term $t$ is macro-free, which ensures that $\interp{\pvec{t}}{\TM}{\calp_1}$ and $\interp{\pvec{t}}{\TM}{\calp_2}$ are \emph{syntactically} the same (base logic) terms in any $\calp_1$-trace model $\TM$.
\item the rule $\textsc{Trans}$ introduces an intermediate protocol $\calp_3$ which must be compatible with $\calp_1$ and $\calp_2$.
\end{itemize}

%% only two/thrre examples of fig 7 in paper (dup, no-if, and the updated if equiv corresponds to equivalent, phi tese_P1 phi <=> phi' and pi tese_p2 phi <=> phi' and u[\phi -> phi'] \sim v[\phi ->\phi'] =>  u \sim v, and xor rule from fig 8, rest in annexe.

\begin{figure}
  \begin{mathpar}
    \inferrule[Expand]{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}
    }{\Gamma \cup \phi \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}}

    \inferrule[F-Cut]{
      \Gamma \vdash_{\calp_1,\calp_2} \phi\\
      \Gamma \cup \phi \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}
    }{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}
    }

    \inferrule[Sym]{
      \Gamma \vdash_{\calp_2,\calp_1} \pvec{u} \sim \pvec{v}
    }{\Gamma \vdash_{\calp_1,\calp_2} \pvec{v} \sim \pvec{u}}

    \inferrule[Refl]{~}
    { \Gamma \vdash_{\calp_1,\calp_2} \pvec{t} \sim \pvec{t} }
    \quad\text{$\pvec{t}$ is macro-free}

    \inferrule[Trans]{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{t}\\
      \Gamma \vdash_{\calp_1,\calp_3} \pvec{t} \sim \pvec{v}
    }{\Gamma \vdash_{\calp_1,\calp_3} \pvec{u} \sim \pvec{v}}
    \quad\text{$\calp_1,\calp_2,\calp_3$ are compatible}

    \inferrule[if-reach]{
      \phi \vdash_{\calp_1} \false \quad       \phi \vdash_{\calp_2} \false
    }{
      \Gamma  \vdash_{\calp_1,\calp_2} \myif \phi \mythen {u} \sim  \myif \phi \mythen {v}
    }

    \inferrule[equiv]{
\Gamma \vdash_{\calp_1}  t_1 \deq t_2 \quad    \Gamma \vdash_{\calp_2}  t_1 \deq t_2 \quad     \Gamma  \vdash_{\calp_1,\calp_2}  \pvec{u}[ t_1 / t_2] \sim  \pvec{v}[ t_1 / t_2]
    }{
      \Gamma \vdash_{\calp_1,\calp_2}
      \pvec{u} \sim  \pvec{v}
    }

    \inferrule[equiv']{
      \phi \vdash_{\calp_1} \phi \Leftrightarrow \psi  \quad     \phi \vdash_{\calp_2} \phi \Leftrightarrow \psi \quad       \Gamma \vdash_{\calp_1,\calp_2}  \pvec{u}[ \phi / \psi] \sim \pvec{v}[ \phi / \psi]
    }{
      \Gamma \vdash_{\calp_1,\calp_2}  \pvec{u} \sim \pvec{v}
    }

    \inferrule[${\lnot}$-R]{
      \Gamma \vdash_{\calp_1,\calp_2} \false \sim \true
    }{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u} \sim \pvec{v}
    }


    \inferrule[if-weak]{
      \Gamma \vdash_{\calp_1,\calp_2} \phi, \pvec{u} \sim \phi, \pvec{v}
    }{
      \Gamma \vdash_{\calp_1,\calp_2} \myif  \phi \mythen \pvec{u} \sim \myif \phi \mythen \pvec{v}
    }

    \inferrule[Dup]{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u},s \sim \pvec{v},t
    }{
      \Gamma \vdash_{\calp_1,\calp_2} \pvec{u},s,s \sim \pvec{v},t,t
    }
  \end{mathpar}
  \caption{Generic inference rules for indistinguishability.}
  \label{fig:lk-ind}
\end{figure}

\begin{lemma}
  The rules presented in \cref{fig:lk-ind} are sound.
\end{lemma}

Remark that $\textsc{equiv}$, $\textsc{equiv'}$ and  $\textsc{if-reach}$  are rules that leverages the reachability prover to obtain proofs of indistinguishability. This is a powerful tool: in an authentication protocol, one may prove in the reachability prover that the condition of an action is equivalent to a formula that expresses the well-authentication of the protocol, and once the condition is replaced inside the indistinguishability goal, the goal may become easy to prove.

\paragraph{Other rules.}

\cref{fig:rules-corresp-equiv} presents the rules for Fresh, PRF and XOR tactics.
We use the following notations:
\begin{itemize}
  \item  $C$ denotes a macro-free context\footnote{If the context is not macro-free, it might be interpreted by distinct values on both sides of a meta-logic rule, and the base-logic axioms do not hold in this case. Notably, the corresponding fresh axiom , $C[0] \sim \pvec{v}, C'[0] \Rightarrow  C[\mathsf{n}] \sim \pvec{v}, C'[\mathsf{n}']$ is not true. This can be witnessed by taking $C[\_]= \myif \_ = 0 \mythen 1 \myelse 0$ and  $C[\_]= \myif \_ = 0 \mythen 1 \myelse 1$, as $C[0]$ and $C'[0]$ are both equal to 1, but with overwhelming probability,  $C[n]$ is equal to 0 and $C'[n']$ to 1.}
\item $A \in S$ stands for every action in the system (or protocol)
\item $A(\pvec i)^L$ represents the left projection of meta-logic bi-terms and bi-formulas describing the action $A(\pvec k)$ (outputs, updates and conditions)
\item $k(\_) \sqsubseteq_{\h(\_,\cdot)} u$ means that the indexed key $k$ appears only in key positions in $u$
\item indices $\pvec i$ in $A(\pvec i)$ are chosen fresh with relation to the appropriate environment (i.e. indices appearing in $u, C, t, k, \pvec {j_0}$)
\end{itemize}

\begin{figure}[h]
  \textbf{Fresh rule:}
  {\small\[\arraycolsep=10pt
      \begin{array}{|c|c|}
        \hline
        \text{Base logic Rule} &
        \text{Meta-logic Rule}\\
        \hline
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Fresh
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \inferrule{
          \Gamma \vdash \pvec{u}, C[0] \sim \pvec{v}, C[0]
        }{
          \Gamma \vdash \pvec{u}, C[\mathsf{n}] \sim \pvec{v}, C[\mathsf{n}']
        }
        &
        \inferrule{
          \Gamma \vdash_{\calp_1,\calp_2}
          {\begin{alignedat}[t]{2}
              &
              \pvec{u},
              C\big[
              \myif \phifresh{\calp_1}{\mathsf{n}[\pvec{i}]}{\pvec{u},C}
              \mythen 0 \myelse \mathsf{n}[\pvec{i}]
              \big]\\
              \sim\;\;&
              \pvec{v},
              C\big[
              \myif \phifresh{\calp_2}{\mathsf{n}'[\pvec{i}']}{\pvec{v},C}
              \mythen 0 \myelse \mathsf{n}'[\pvec{i}']
              \big]
            \end{alignedat}}
        }{
          \Gamma \vdash_{\calp_1,\calp_2}
          \pvec{u}, C[\mathsf{n}[\pvec{i}]] \sim \pvec{v}, C[\mathsf{n}'[\pvec{i}']]
        }\\[2em]
        \text{where }
        \mathsf{n} \not \in \st(\pvec{u},C)
        \text{ and }
        \mathsf{n}' \not \in \st(\pvec{v},C)
        &
        \text{where }
        \begin{alignedat}[t]{2}
          &\phifresh{\calp}{\mathsf{n}[\pvec{i}]}{\pvec{u}}
          &\;\;\overset{def}{=}\;\;&
          \quad
          \bigwedge_{\mathclap{(\mathsf{n}[\pvec{j}],\pvec{j},c) \in \ost_{\calp}(\pvec{u})}}
          \quad
          \forall \pvec{j}, c \rightarrow \pvec{i} \ne \pvec{j}
        \end{alignedat}
        \\\hline
      \end{array}
    \]}

  \textbf{PRF Rule:}
  {\small\[\arraycolsep=10pt
      \begin{array}{|c|c|}
        \hline
        \text{Base logic Rule} &
        \text{Meta-logic Rule}\\
        \hline
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % PRF
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \inferrule{
          \Gamma \vdash
          \pvec{u},
          C\Big[\;
          {\begin{alignedat}[c]{1}
              \myif \phihfresh{}{\mathsf{k}}{t}{\pvec{u},C,t}
              &\mythen \mathsf{n}\\[-0.5em] &\myelse h(t,\mathsf{k})
            \end{alignedat}}
          \;\Big]
          \sim
          \pvec{v}, s
        }{
          \Gamma \vdash
          \pvec{u}, C[h(t,\mathsf{k})] \sim \pvec{v}, s
        }
        &
        \inferrule{
          \Gamma \vdash_{\calp_1,\calp_2}
          \pvec{u},
          C\Big[\;
          {\begin{alignedat}[c]{1}
              \myif \phihfresh{\calp_1}{\mathsf{k}[\pvec{i}]}{t}{\pvec{u},C,t}
              &\mythen \mathsf{n}\\[-0.5em] &\myelse h(t,\mathsf{k}[\pvec{i}])
            \end{alignedat}}
          \;\Big]
          \sim
          \pvec{v}, s
        }{
          \Gamma \vdash_{\calp_1,\calp_2}
          \pvec{u}, C[h(t,\mathsf{k}[\pvec{i}])] \sim \pvec{v}, s
        }
        \\[2em]
        \text{when }
        \mathsf{n} \text{ fresh},
        \mathsf{k} \tpos_{h(\_,\cdot)} \st(\pvec{u},C,t)
        &
        \text{when }
        \mathsf{n} \text{ fresh},
        \mathsf{k} \tpos^{\calp_1}_{h(\_,\cdot)} \st(\pvec{u},C,t)
        \\[1em]
        \text{and }
        \begin{alignedat}[t]{2}
          &\phihfresh{}{\mathsf{k}}{t}{\pvec{u}}
          &\;\;\overset{def}{=}\;\;&
          \quad
          \bigwedge_{\mathclap{h(m,\mathsf{k}) \in \st(\pvec{u})}}
          \quad
          m \ne t
        \end{alignedat}
        &
        \text{and }
        \begin{alignedat}[t]{2}
          &\phihfresh{\calp}{\mathsf{k}[\pvec{i}]}{t}{\pvec{u}}
          &\;\;\overset{def}{=}\;\;&
          \quad
          \bigwedge_{\mathclap{(h(m,\mathsf{k}[\pvec{i_0}]),\pvec{j},c) \in \ost_{\calp}(\pvec{u})}}
          \quad
          \forall \pvec{j},
          (c \wedge \pvec{i} = \pvec{i_0})
          \rightarrow m \ne t
        \end{alignedat}
        \\\hline
      \end{array}
    \]}

  \textbf{XOR Rule:}
  {\small
    \[\arraycolsep=10pt
      \begin{array}{|c|c|}
        \hline
        \text{Base logic Rule} &
        \text{Meta-logic Rule}\\
        \hline
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % XOR
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \inferrule{
          \Gamma \vdash \mylen(t) = \mylen(\mathsf{n})\\\\
          \Gamma \vdash
          \pvec{u}, C[\mathsf{m}] \sim \pvec{v}, s
        }{
          \Gamma \vdash
          \pvec{u}, C[t \oplus \mathsf{n}] \sim \pvec{v}, s
        }
        &
        \inferrule{
          \lreach{\Gamma} \vdash_{\calp_1}
          \mylen(t) = \mylen(\mathsf{n}[\pvec{j}])\\\\
          \Gamma \vdash_{\calp_1,\calp_2}
          \pvec{u},
          C\Big[\;
          {\begin{alignedat}[c]{1}
              \myif \phifresh{\calp_1}{\mathsf{n}[\pvec{j}]}{\pvec{u},C,t}
              &\mythen \mathsf{m}\\[-0.5em] &\myelse t \oplus \mathsf{n}[\pvec{j}]
            \end{alignedat}}
          \;\Big]
          \sim
          \pvec{v}, s
        }{
          \Gamma \vdash_{\calp_1,\calp_2}
          \pvec{u}, C[t \oplus \mathsf{n}[\pvec{j}]] \sim \pvec{v}, s
        }
        \\[2em]
        \text{when }
        \mathsf{m} \text{ fresh and }
        \mathsf{n} \not \in \st(\pvec{u},C,t)
        &
        \text{when }
        \mathsf{m} \text{ fresh and }
        \begin{alignedat}[t]{2}
          &\phifresh{\calp}{\mathsf{n}[\pvec{i}]}{\pvec{u}}
          &\;\;\overset{def}{=}\;\;&
          \quad
          \bigwedge_{\mathclap{(\mathsf{n}[\pvec{j}],\pvec{j},c) \in \ost_{\calp}(\pvec{u})}}
          \quad
          \forall \pvec{j}, c \rightarrow \pvec{i} \ne \pvec{j}
        \end{alignedat}
        \\\hline
      \end{array}
    \]}

  \adrien{I use the function $\lreach{\Gamma}$ in the XOR rule, which extracts from $\Gamma$ the \emph{left} reachability statements. If we keep it, I will add the definition.}


  \caption{Rules of the base logic, and corresponding meta-logic rules.}
  \label{fig:rules-corresp-equiv}
\end{figure}

\cref{fig:fadup} describes the  $\textsc{FA-DUP}$ rule.
This rule allows to remove from the frame some meta-formula
$\phi$ that can already be computed by the attacker
using the information he obtained from a past execution.
The rule assumes that $\mframe @ T$ is available
on both sides of the equivalence. These frames mean that the
attacker has $\mout @ T'$ for some $T'$, provided that $T' \leq A(\pvec i)$
and $\mexec @ T'$ holds.
In order to obtain these conditions, we impose that formulas $\phi$
occurs in a context where $\mexec @ T$ can be assumed to hold,
and we impose that $\phi$ belongs to a syntactic fragment $H_{\{T\}}$
guaranteeing (among other things)
that its $\minp @ T'$ subterms are for timestamps $T' \leq T$.

The rule would also be sound if we replace $\mexec @ T \wedge \phi$
by $\mexec @ T \Rightarrow \phi$ or
$\myif \mexec @ T \mythen t \myelse \false$ where $t \in H_{\{T\}}$
is a honest meta-term.
The conditions imposed on formulas of $H_{\{T\}}$ are not sensitive
to the associativity-commutativity of conjunction, and more generally
to boolean equivalences, which our implementation exploits for more
flexibility: for instance, we consider that
$((T_1 \leq T \wedge T_2 \leq T) \Rightarrow \phi') \in H_S$
when
$\phi' \in H_{S \cup \{T_1,T_2\}}$ and $T \in S$.
Our implementation also allows the use of conditionals, lookups and
sequences in meta-terms.

\begin{figure}[h]
  \begin{mathpar}
    \inferrule[FA-DUP]{
      \Gamma \vdash_{\calp_1,\calp_2}
      \pvec u, \mframe @ T \sim \pvec v, \mframe @ T
    }{
      \Gamma \vdash_{\calp_1,\calp_2}
      \pvec u, \mframe @ T, \mexec @ T \wedge \phi
      \sim
      \pvec v, \mframe @ T, \mexec @ T \wedge \phi
    }
  \end{mathpar}
  We require that $\phi \in H_{\{T\}}$ where, for any set $S$ of
  timestamps, $H_S$ is the least set of meta-formulas and meta-terms
  that contains atomic meta-formulas over indices and timestamps,
  that is closed under function application, boolean connectives,
  and the following rules,
  where $\mathcal{Q}$ stands for an arbitrary
  quantification over timestamp or index variables, and the quantified
  variable is assumed to be disjoint from the variables occurring in $S$:
  $$
  \inferrule{
    T \in S
    \quad
    \phi \in H_{S\cup\{T'\}}
  }{
    (T' \leq T \Rightarrow \phi) \in H_S
  }
  \quad\quad
  \inferrule{
    T \in S
    \quad
    \phi \in H_{S\cup\{T'\}}
  }{
    (T' \leq T \wedge \phi) \in H_S
  }
  \quad\quad
  \inferrule{\phi\in H_S}{{\cal Q}.\phi \in H_S}
  \quad\quad
  \inferrule{t,t' \in H_S}{(t = t') \in H_S}
  $$
  $$
  \inferrule{T \in S \text{ or } \pre(T) \in S}{
    \minp @ T \in H_S
  }
  \quad\quad
  \inferrule{T \in S}{
    \mout @ T \in H_S
  }$$
  % David: je crois qu'on n'utilise pas cette possibilité,
  % je la cache pour simplifier.
  % $$
  % \inferrule{\phi \in H_S \quad B(\pvec j) \in S}{
  %   (\myif \mexec @ B(\pvec j) \mythen \phi \myelse \psi) \in H_S}
  % $$
  \caption{FA-DUP rule.}
  \label{fig:fadup}
\end{figure}

\begin{proposition}
  The rule \textsc{FA-DUP} is sound.
\end{proposition}
\begin{proof}
  \emph{For the proof I ignore $\Gamma$ because it is just carried around,
  and to treat it formally I would need notations that we have not designed
  yet.}
  Consider some trace model $\TM$,
  and assume that
  $(\pvec u,\mframe @ T)^\TM_{\calp_1} \sim
   (\pvec v,\mframe @ T)^\TM_{\calp_2}$
  is a valid base-logic formula.
  We show that
  $$
  \interp{\pvec u}{\TM}{\calp_1},
  \interp{\mframe @ T}{\TM}{\calp_1},
  (\mexec @ T \wedge \phi)^\TM_{\calp_1}
  \sim
  \interp{\pvec v}{\TM}{\calp_2},
  \interp{\mframe @ T}{\TM}{\calp_2},
  (\mexec @ T \wedge \phi)^\TM_{\calp_2}.
  $$
  Using equational reasoning on $\dand$, we can replace
  $\interp{\mexec @ T}{\TM}{\calp_1} \dand \interp{\phi}{\TM}{\calp_1}$ by
  $$\interp{\mexec @ T}{\TM}{\calp_1} \dand
  \myif \interp{\mexec @ T}{\TM}{\calp_1}
  \mythen \interp{\phi}{\TM}{\calp_1} \myelse \false$$
  and similarly on the other side.
  Then by \textsc{FA} and \textsc{Dup} on $\mexec @ T$,
  we reduce our equivalence to proving the one where the last items
  of frames are replaced by
  $
  \myif \interp{\mexec @ T}{\TM}{\calp_i}
  \mythen \interp{\phi}{\TM}{\calp_i} \myelse \false
  $:
  in more detail, we observe that
  $\EQ\bigl(\interp{\mexec @ T}{\TM}{\calp_i},
       \interp{\fst(\fst(\mframe @ T))}{\TM}{\calp_i}\bigr)\sim\true$
  holds, which allows us to replace the first term by the second,
  to conclude by removing the applications of $\fst$ using \textsc{FA}
  and get rid of $\mframe @ T$ using \textsc{Dup}.

  We will actually prove more generally that
  $$
  \begin{array}{rl}
    &
    \pvec U,
    \interp{\mframe @ T}{\TM}{\calp_1},
    \myif \interp{\mexec @ T}{\TM}{\calp_1}
    \mythen \interp{\xi}{\TM'}{\calp_1} \myelse \false
    \\ \sim &
    \pvec V,
    \interp{\mframe @ T}{\TM}{\calp_2},
    \myif \interp{\mexec @ T}{\TM}{\calp_2}
    \mythen \interp{\xi}{\TM'}{\calp_2} \myelse \false
  \end{array}
  $$
  for any sequences of base terms $\pvec U$ and $\pvec V$,
  for any $\TM'$ that only differs from $\TM$ for the semantic
  assignment of variables that do not occur in $T$,
  and for any meta-formula or meta-term $\xi$ such that $\xi \in H_S$
  for some set $S$ containing $T$ and such that\footnote{
    We do not specify $\calp_1$ or $\calp_2$ here
    as they are irrelevant to the interpretation of timestamp meta-terms.
  } $\interp{T'}{\TM'}{}\leq\interp{T}{\TM'}{}$ for all $T'\in S$.

  We proceed by induction on the structure of meta-formulas and meta-terms.
  \begin{itemize}
    \item Assume $\phi$ is of the form $\phi_1\wedge\phi_2$ with
      $\phi_1,\phi_2\in H_S$. By equational reasoning we can replace
      $\myif \interp{\mexec @ T}{\TM}{\calp_1}
      \mythen \interp{\phi}{\TM'}{\calp_1} \myelse \false$
      by
      $$
      (\myif \interp{\mexec @ T}{\TM}{\calp_1}
       \mythen \interp{\phi_1}{\TM'}{\calp_1} \myelse \false)
      \dand
      (\myif \interp{\mexec @ T}{\TM}{\calp_1}
       \mythen \interp{\phi_2}{\TM'}{\calp_1} \myelse \false)$$
     and similarly on the other side.
     We conclude by the \textsc{FA} rule on $\dand$ and induction
     hypotheses on $\phi_1$ and $\phi_2$.
   \item Assume $\phi$ is of the form $T' \leq T \Rightarrow \phi'$.
     There are two subcases:
     \begin{itemize}
       \item If $\interp{T'}{\TM'}{} \leq \interp{T}{\TM'}{}$ then
         $\interp{T' \leq T \Rightarrow \phi'}{\TM'}{\calp_i} =
         \true \dimpl \interp{\phi'}{\TM'}{\calp_i}$ for each $i$.
         By equational reasoning on $\dimpl$ we can thus replace
         the interpretation of $\phi$ by that of $\phi'$.
         Moreover, our condition on $S$ extends to $S \cup \{T'\}$.
         We conclude by induction hypothesis on
         $\phi' \in H_{S\cup\{T'\}}$.
       \item Otherwise, each
         $\interp{T' \leq T \Rightarrow \phi'}{\TM'}{\calp_i}$ can be
         replaced by $\true$ and we conclude by \textsc{FA}
         on each $\myif \interp{\mexec @ T}{\TM}{\calp_i} \mythen \true
         \myelse \false$, followed
         by \textsc{FA} on $\true$ and $\false$,
         and \textsc{Dup} on $\mexec @ T$.
     \end{itemize}
   \item
     The case of $T' \leq T \wedge \phi'$ is similar to the
     second case above.
     The cases of remaining boolean connectives is similar to the
     first one above.
   \item Assume $\phi$ is of the form ${\cal Q}.\phi'$.
     By definition, $\interp{\phi}{\TM'}{\calp_i}$
     is a boolean combination
     of $\interp{\phi'}{\TM''}{\calp_i}$
     where $\TM''$ only differs from $\TM'$ in its semantic assignment
     for the quantified variable.
     Since this variable is assumed to not occur in $S$,
     the condition on $S$ wrt.\ $\TM'$ also holds wrt.\ $\TM''$,
     and the condition $\TM'$ wrt.\ $T$ also holds wrt.\ $\TM''$.
     We proceed as we did in the first case for a simple boolean combination,
     i.e.\ by pushing the conditional on $\mexec @ T$ underneath boolean
     connectives, using \textsc{FA} on boolean connectives and concluding
     by induction hypotheses on $\phi'$ and $\TM''$.
   \item If $\phi$ is an atom over index or timestamp meta-terms,
     then $\interp{\phi}{\TM'}{\calp_1} = \interp{\phi}{\TM'}{\calp_1}$
     and is either $\true$ or $\false$. We can thus conclude
     by induction hypothesis.
   \item If $\phi$ is an atom $t = t'$ over meta-terms of sort message,
     we have $\interp{\phi}{\TM'}{\calp_i} =
      \EQ(\interp{t}{\TM'}{\calp_i},\interp{t'}{\TM'}{\calp_i})$ and
     we conclude by \textsc{FA} on $\EQ$ and induction hypotheses
     on $t$ and $t'$ since they must belong to $H_S$.
   \item The case of a meta-term $t$ of the form $f[\pvec i](\pvec t')$
     is treated, as before, using \textsc{FA} on $f_{\sigma_\I(\pvec i)}$
     and induction hypotheses on the honest subterms of $\pvec t'$.
   \item Consider the case of a meta-term $\mout @ T'$ for some $T' \in S$.
     By hypothesis on $S$ we have $\interp{T'}{\TM'}{} \leq \interp{T}{\TM'}{}$.
     Thus, by definition of $\interp{\mframe @ T}{\TM}{\calp_i}$,
     there exists some context $C$ using $\fst$ and $\snd$
     such that
     $$\EQ\bigl(
     \interp{
       \myif \mexec @ T' \mythen \mout @ T'}{\TM}{\calp_i},
     C[\interp{\mframe @ T}{\TM}{\calp_i}]\bigr) \sim \true.$$
     Note that we omitted the $\mathsf{else}$ branch for conciseness, and
     since it does not play a role.
     Next, since $\interp{\mexec @ T}{\TM}{\calp_i} =
     \interp{\mexec @ T}{\TM'}{\calp_i}$ and since it is a conjunction of
     $\interp{\mexec @ T'}{\TM'}{\calp_i}$ and other terms, we have:
     $$\EQ\bigl(
     \myif \interp{\mexec @ T}{\TM}{\calp_i} \mythen
       \interp{\mout @ T'}{\TM}{\calp_i},
     \myif \interp{\mexec @ T}{\TM}{\calp_i} \mythen
     C[\interp{\mframe @ T}{\TM}{\calp_i}]
     \bigr)
     \sim \true.$$
     We obtain our equivalence statement
     by performing the replacement permitted by this equality,
     and conclude by \textsc{FA} on the conditional, then on the
     uses of $\fst$ and $\snd$, to finally remove $\mexec @ T$ and
     $\mframe @ T$ as duplicates.
   \item Finally, if we have a meta-term $\minp @ T'$ where either $T' \in S$
     of $\pre(T') \in S$, we have
     $\interp{\minp @ T'}{\TM'}{\calp_i} =
      \att(\interp{\mframe @ \pre(T')}{\TM'}{\calp_i})$.
     By hypothesis on $T'$ we have
     $\interp{\pre(T')}{\TM'}{} \leq \interp{T}{\TM'}{}$.
     Moreover, $\interp{\mframe @ \pre(T')}{\TM'}{\calp_i}$
     is a subterm of $\interp{\mframe @ T}{\TM'}{\calp_i} =
     \interp{\mframe @ T}{\TM}{\calp_i}$.
     which can be accessed using a number of applications of $\snd$.
     We can thus replace
     $\interp{\minp @ T'}{\TM'}{\calp_i}$
     by $\att(\snd^n(\interp{\mframe @ T}{\TM}{\calp_i}))$,
     which allows to conclude using \textsc{FA} and \textsc{Dup}.
  \end{itemize}
\end{proof}

We also provide in the calculus rules that are either direct translation from the base logic, or slight variations of the previous examples.
\begin{itemize}
\item We provide a rule for the Decisional Diffie-Hellman assumption, based on the $\BC$ rule presented in~\cite{bana2019verification}.
\item We provide a rule for the key privacy axioms of encryptions and the $\textsc{CCA}_1$ axiom, based on the $\BC$ rule from~\cite{Bana:2014:CCS:2660267.2660276}.

\end{itemize}


\clearpage
\section{Archives}
\subsection{A proof technique}

Diff-equivalence is usually proved by induction and case analysis on
the timestamp. Even cases where the left and right actions are locally
identical are not trivial: it may be e.g.\ that the same name is outputted
by the action on both sides, but that each side has previously released
different information on that name.

To prove diff-equivalence, it can be interesting to prove that:
\[
  \phi^L_\tr, \phi^R_\tr
  \vdash_{\calp_1,\calp_2}
  \phi^L_\alpha \Leftrightarrow \phi^R_\alpha
\]

Then, in the induction step, we can directly replace the previous conditions by the same one.


This condition is only used to help for proving diff-equivalence, it is not necessary.
The gap comes from the fact that we are requiring conditions to be
synchronized for all random samplings.

\begin{example}
  With the bi-protocol of \cref{ex:negl} we would have to prove
  $\vdash_{\calp_1,\calp_2} g() = n \Leftrightarrow g() = m$ and
  $g()=n, g()=m \vdash_{\calp_1,\calp_2} \ok \sim \ok$, both of which hold.
  With the bi-protocol of \cref{ex:sync} we would have to prove
  $\vdash_{\calp_1,\calp_2} g() = (n)_0 \Leftrightarrow g() = (m)_0$ which does not hold.
\end{example}

\begin{example} \label{ex:indep}
  This proof technique does not work for \cref{ex:problem}.
  The same problem appears with the Basic-Hash protocol, even if we work around
  the problem described in \cref{sec:refined-diff}, we won't be able to show
  that conditionals are synchronized.  In the simple case of the trace
  $T(i,j).R(k,i,j)$ we have
  on the single-session side
  $$\pi_2(g_2(\pair{n_T(i,j),h(n_T(i,j),k'(i,j))})) =
  h(\pi_1(g_2(\ldots)),k'(i,j))$$
  and we would like this to imply (in the meta-logic)
  the same equality with $k(i)$ instead of $k'(i,j)$.
  This implication does not hold with overwhelming probability in all
  computational models: as in \cref{ex:problem}, $g_2(x)$ could be the second
  projection of $x$ with its first bit changed to $0$; if the hash is PRF,
  there should be a probability of roughly $1 \over 4$ that this leaves
  the hash unchanged with $k'(i,j)$ but not with $k(i)$.
\end{example}

\section{Outdated example : a signed DDH key exchange}
\charlie{abus de notations dans cette partie}

We briefly show how one can prove the security of a signed DDH key exchange. The protocol in pi-calculus is provided in Figure~\ref{fig:signed_ddh} and the run of an honest execution in Figure~\ref{fig:dh_ke}. This example is a simplified instance of classical key-exchange security. Notably, we assume that identities are already fixed.

\begin{figure}
  % \setlength{\belowcaptionskip}{-15pt}
  \setmsckeyword{} \drawframe{no}
  \setmscscale{0.9}
  \begin{center}
    \begin{msc}{}
      \setlength{\instwidth}{0\mscunit}
      \setlength{\instdist}{7cm}
      \setlength{\topheaddist}{0cm}
      \declinst{initiator}{
        \begin{tabular}[c]{c}
          \textsc{A} \\
          \colorbox{gray}{{\;\; $sk_A,a_i$\;\;}}
        \end{tabular}}{}

      \declinst{receiver}{
        \begin{tabular}[c]{c}
          \textsc{B} \\
          \colorbox{gray}{{\;\;  $sk_B,b_i$ \;\;}}
        \end{tabular}}{}

      \nextlevel[-1]
      \mess{$\mysign(g^{a_i},sk_A)$}{initiator}{receiver}
      \nextlevel[1.5]
      \mess{$\mysign(<g^{a_i},g^{b_i}>,sk_B)$}{receiver}{initiator}
      \nextlevel[1.5]
      \mess{$\mysign(<g^{a_i},g^{b_i}>,sk_A)$}{initiator}{receiver}




    \end{msc}
  \end{center}
  \caption{Diffie Hellman key exchange}\label{fig:dh_ke}
\end{figure}

\begin{figure}
  \[
    \begin{array}{cc}
      \begin{array}[t]{l@{~}l}
        A_i := & \aout{\mysign(g^{a_i},sk_A)} : \alpha_1; \\
        &\ain{x}; \\
        & \myif \mycsign(x,pk(sk_B)) \\
        & ~ \wedge \pi_1(\mygetmess(x))=g^{a_i}  \mythen \\
        & \quad \aout{\mysign(\mygetmess(x),sk_A) } : \alpha_2; \\
        & \quad \myfind j \mysuchthat g^{b_j} = \pi_2(\mygetmess(x)) \\
        & \qquad \aout{\diff{\pi_2(\mygetmess(x))^{a_i}}{k_{i,j}}} : \alpha_3\\
        & \quad \myelse \\
        & \qquad \aout{\diff{\pi_2(\mygetmess(x))^{a_i}}{\bot}}  : \alpha_4 \\
        & \myelse \\
        & \bot
      \end{array}
      &
      \begin{array}[t]{l@{~}l}
        B_i := &\ain{x}; \\
        & \myif \mycsign(x,pk(sk_A)) \mythen \\
        & \quad \aout{\mysign(<\mygetmess(x), g^{b_i}>,sk_B)} : \beta_1; \\
        & \quad \ain{y}; \\
        & \quad \myif \mycsign(y,pk(sk_A))\\
        & \quad ~ \wedge \mygetmess(y) = <\mygetmess(x), g^{b_i}> \mythen \\
        & \quad \quad \myfind j \mysuchthat g^{a_j} = \mygetmess(x) \\
        & \quad \qquad \aout{\diff{\mygetmess(x)^{b_i}}{k_{j,i}}} : \beta_2 \\
        & \quad \quad \myelse \\
        & \quad \qquad \aout{\diff{\mygetmess(x)^{b_i}}{\bot}} : \beta_3 \\
        & \quad \myelse \\
        & \quad \bot \\
        & \myelse \\
        & \bot
      \end{array}
    \end{array}
  \]
  \label{fig:signed_ddh}
  \caption{A signed DDH key exchange}
\end{figure}

We outline the proof of the fact that $!_i A_i \| B_i$ is diff-equivalent. There are four actions with choices in the output, thus, we have to show that, for all trace $\tr$, for all $i,j$:
\begin{enumerate}
\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(x,pk(sk_B)), \mygetmess(x)=<g^{a_i}, g^{b_j}>, \mouts_\tr^L \sim \mouts_\tr^R,  \\
    \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{a_i} \sim \mouts_\tr^R, k_{i,j}
  \end{array}
  $ ($\alpha_3$)

\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(x,pk(sk_B)),  \not \exists j. \pi_2(mygetmess(x))= g^{b_j},  \mouts_\tr^R \sim \mouts_\tr^L \\
    \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{a_i} \sim \mouts_\tr^R, \bot
  \end{array} $ ($\alpha_4$)
\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(y,pk(sk_A)), \mycsign(x,pk(sk_A)), \mygetmess(y)=<g^{a_j}, g^{b_i}>,  \mouts_\tr^R \sim \mouts_\tr^L \\ \quad \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{b_i} \sim \mouts_\tr^R, k_{j,i}
  \end{array}$ ($\beta_2$)
\item $\begin{array}[t]{l}
    \phi_\tr,  \mycsign(y,pk(sk_A)), \mycsign(x,pk(sk_A)),  \not \exists j. \pi_2(mygetmess(x))= g^{b_j},  \mouts_\tr^R \sim \mouts_\tr^L\\
    \vDash \mouts_\tr^L, \pi_2(\mygetmess(x))^{b_i} \sim \mouts_\tr^R, \bot
  \end{array}$ ($\beta_3$)
\end{enumerate}

Regarding goal $(2)$ and $(4)$, we remark that it is a case where $\Gamma \vdash \false$. Indeed, for $(2)$ applying EUFCMA yields that there exists $j$ such that $x = \mysign(<g^{a_i},g^{b_j}>,sk_B)$ which is in contradiction with  $\not \exists j. \pi_2(mygetmess(x))= g^{b_j}$.

Regarding goals $(1)$ and $(3)$, we mainly use DDH. To this end, we first use EUFMCA, to ensure that we have a matching conversation between the two sessions, and then use DDH. \charlie{je détail pas, ça prend du temps de formaliser proprement DDH vis à vis des actions, et je pense pas que ce soit l'objectif actuel}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
