(* EUF trace tactic *)
open Squirrelcore
open Term
open Utils
open Ppenv

module Args = TacticsArgs
module L = Location
module SE = SystemExpr

module TS = TraceSequent

type sequent = TS.sequent

type lsymb = Typing.lsymb

module MP = Match.Pos
module Sp = MP.Sp

open LowTactics

(*------------------------------------------------------------------*)
let wrap_fail = TraceLT.wrap_fail
let soft_failure = Tactics.soft_failure
let hard_failure = Tactics.hard_failure

(*------------------------------------------------------------------*)
(* Instantiating the occurrence search module *)

module O = Occurrences
module Name = O.Name
type name = Name.t


(** We search at the same time for bad ocurrences of the key, and for
    protected (signed/hashed) messages (with a key) *)
type integrity_content =
  | BadKey of name
  | IntegrityMsg of {msg:Term.term; key:name}


module IntegrityOC : O.OccurrenceContent with type content = integrity_content
                                          and type data = unit =
struct
  type content = integrity_content
  type data = unit

  let collision_formula ~(negate : bool)
      ~(content : content) ~(collision : content) ~(data : unit)
    : Term.term
    =
    let _ = data in
    match content, collision with
    | BadKey k, BadKey kcoll ->
      (* sanity check: only apply when same symbol *)
      assert (k.symb = kcoll.symb);
      if not negate then
        Term.mk_eqs ~simpl:true ~simpl_tuples:true kcoll.args k.args
      else
        Term.mk_neqs ~simpl:false ~simpl_tuples:true kcoll.args k.args

    | IntegrityMsg im, IntegrityMsg imcoll ->
      (* sanity check: key must have same symbol in both messages *)
      assert (im.key.symb = imcoll.key.symb);
      if not negate then
        mk_and
          (mk_eq ~simpl:true imcoll.msg im.msg)
          (mk_eqs ~simpl:true ~simpl_tuples:true imcoll.key.args im.key.args)
      else
        mk_impl
          (mk_eqs ~simpl:true ~simpl_tuples:true imcoll.key.args im.key.args)
          (mk_neq ~simpl:true imcoll.msg im.msg)
    | _ ->
      (* sanity check: we should never record a collision between two things
         with a different constructor *)
      assert false

  let subst_content sigma x =
    match x with
    | BadKey k -> BadKey (Name.subst sigma k)
    | IntegrityMsg im -> IntegrityMsg  {msg=Term.subst sigma im.msg;
                                        key=Name.subst sigma im.key}

  let subst_data _ () = ()

  let pp_content ppe fmt x =
    match x with
    | BadKey k -> Fmt.pf fmt "%a" (Name.pp ppe) k
    | IntegrityMsg im ->
      Fmt.pf fmt "%a auth. by %a" (Term._pp ppe) im.msg (Name.pp ppe) im.key

  let pp_data _ppe fmt () : unit =
    Fmt.pf fmt ""
end

module IOC = IntegrityOC
module IOS = O.MakeSearch (IOC)
module IOF = O.MakeFormulas (IOS.EO)
let mk_simple_occ = IOS.EO.SO.mk_simple_occ


(*------------------------------------------------------------------*)
(* Look for occurrences using the Occurrences module *)

(** A [IOS.f_fold_occs] function.
    Looks for
    1) bad occurrences of the key [k]: places where a key with the same symbol
       as [k] is used other than in key position
    2) occurrences of protected (signed/hashed) messages, with a key that has
       the same symbol as [k]. *)
let get_bad_occs
    (m : Term.term)
    (k : name)
    (int_f : Symbols.fname) (* function with integrity (hash, signature) *)
    ?(pk_f : Symbols.fname option=None) (* public key function. Must be None iff hash *)
    ~(retry : unit -> IOS.simple_occs)
    ~(rec_call : O.pos_info -> Term.term -> IOS.simple_occs)
    (info : O.pos_info)
    (t : term) 
  : IOS.simple_occs
  =
  (* handles a few cases, using rec_call_on_subterm for rec calls,
     and calls retry_on_subterm for the rest *)
  match t with
  (* occurrence of the signing/hash key *)
  | Name (ksb', kargs') as k' when ksb'.s_symb = k.symb.s_symb ->
    (* generate an occ, and also recurse on kargs' *)
    let occs1 = List.concat_map (rec_call info) kargs' in
    let oc =
      mk_simple_occ
        ~content:(BadKey (Name.of_term k'))
        ~collision:(BadKey k)
        ~data:()
        ~vars:info.pi_vars
        ~cond:info.pi_cond
        ~typ:info.pi_occtype
        ~sub:info.pi_subterm
        ~show:Show
    in
    oc :: occs1

  (* occurrence of the public key (for the signature case only) *)
  | App (Fun (f, _), [tk']) when pk_f = Some f -> (* public key *)
    begin
      match O.expand_macro_check_all (O.get_expand_info info) tk' with
      | Name (_, tkargs') ->
        List.concat_map (rec_call info) tkargs'
      (* pk(k'): no occ,
         even if k'=k, just look in k' args *)
      | _ -> retry () (* otherwise look in tk' *)
    end

  (* hash verification oracle: test u = h(m', k).
     Search recursively in u, m', kargs', but do not record
     m' as a hash occurrence. *)
  | App (Fun (f, _), [u; App (Fun (g, _), [Tuple [m'; Name (ksb', kargs')]])])
    when f = f_eq && g = int_f && pk_f = None && ksb'.s_symb = k.symb.s_symb ->
    List.concat_map
      (rec_call {info with pi_subterm=t}) (* we change the
                                                         subterm *)
      (u :: m' :: kargs')

  (* hash verification oracle (converse case h(m', k) = u). *)
  | App (Fun (f, _), [App (Fun (g, _), [Tuple [m'; Name (ksb', kargs')]]); u])
    when f = f_eq && g = int_f && pk_f = None && ksb'.s_symb = k.symb.s_symb ->
    List.concat_map
      (rec_call {info with pi_subterm=t})
      (u :: m' :: kargs') (* we change st here as well*)

  (* hash/sign/etc w/ a name that could be the right key *) 
  (* record this hash occurrence, but allow the key *)
  (* q: actually why don't we always do this,
               even if it's the wrong key?
     a: that would be sound but generate too many occs *)
  | App (Fun (f, _), [Tuple [m'; Name (ksb', kargs') as k']])
    when f = int_f && k.symb.s_symb = ksb'.s_symb ->
    let occs = List.concat_map (rec_call info) (m' :: kargs') in
    occs @
    [ mk_simple_occ
        ~content:(IntegrityMsg {msg=m'; key=Name.of_term k'})
        ~collision:(IntegrityMsg {msg=m ; key=k})
        ~data:()
        ~vars:info.pi_vars
        ~cond:info.pi_cond
        ~typ:info.pi_occtype
        ~sub:info.pi_subterm
        ~show:Show] (* TODO maybe we don't actually want to print it? *)

  | _ -> retry ()



(*------------------------------------------------------------------*)
(** {2 EUF tactic} *)

(** parameters for the integrity occurrence: key, signed or hashed message,
    signature checked or compared w/ the hash, sign/hash function,
    pk function if any *) 
type euf_param = {
  ep_key    : Name.t;
  ep_intmsg : term;
  ep_term   : term;
  ep_int_f  : Symbols.fname;
  ep_pk_f   : Symbols.fname option;
}

(** Finds the parameters of the integrity functions used in the hypothesis,
    if any *)
let euf_param
    ~(hyp_loc : L.t)
    (contx : Constr.trace_cntxt)
    (hyp : term)
    (s : TS.sequent)
  : euf_param
  =
  let fail () =
    soft_failure ~loc:hyp_loc
      (Tactics.Failure "can only be applied on an hypothesis of the form \
                        checksign(m, s, pk(k)), hash(m, k) = t, or the symmetric equality")
  in
  let einfo = O.EI_direct, contx in
  let table = contx.table in

  (* try to write hyp as u = v *)
  match TS.Reduce.destr_eq s Equiv.Local_t hyp with
  | Some (u, v) -> (* an equality: try to see u or v as h(m, k) *)
    let u = O.expand_macro_check_all einfo u in
    let v = O.expand_macro_check_all einfo v in
    let try_t (t:term) (t':term) : euf_param option =
      match t with
      | App (Fun (f, _), [Tuple [m; tk]]) ->
        begin
          match O.expand_macro_check_all einfo tk with
          | Name _ as k when Symbols.OpData.(is_abstract_with_ftype f Hash table) ->
            Some {ep_key=Name.of_term k; ep_intmsg=m; ep_term=t';
                  ep_int_f=f; ep_pk_f=None}
          | _ -> None
        end
      | _ -> None
    in
    begin
      match try_t u v with
      | Some p -> p
      | None ->
        match try_t v u with
        | Some p -> p
        | None -> fail ()
    end
  | None -> (* not an equality: try to see if it's checksign(m,s,pk) *)
    match O.expand_macro_check_all einfo hyp with
    | App (Fun (f, _), [Tuple [m; s; tpk]]) ->
      begin
        match O.expand_macro_check_all einfo tpk with
        | App (Fun (g, _), [tk]) ->
          begin
            match Typing.check_signature table f g, 
                  O.expand_macro_check_all einfo tk with
            | Some sg, (Name _ as k) ->
              {ep_key= Name.of_term k; ep_intmsg=m; ep_term=s;
               ep_int_f=sg; ep_pk_f=Some g}
            | _ -> fail ()
          end
        | _ -> fail ()
      end
    | _ -> fail ()


(*------------------------------------------------------------------*)
let euf (h : lsymb) (s : sequent) : sequent list =
  let ppe = default_ppe ~table:(TS.table s) () in
  (* find parameters *)
  let _, hyp = TS.Hyps.by_name_k h Hyp s in
  let hyp = as_local ~loc:(L.loc h) hyp in (* FIXME: allow global hyps? *)
  let contx = TS.mk_trace_cntxt s in
  let env = TS.env s in

  let {ep_key=k; ep_intmsg=m; ep_term=t; ep_int_f=int_f; ep_pk_f=pk_f} =
    euf_param ~hyp_loc:(L.loc h) contx hyp s
  in

  let pp_k ppf () =
    Fmt.pf ppf "bad occurrences of key %a,@ and messages authenticated by it" 
      (Name.pp ppe) k
  in

  (* apply euf: first construct the IOS.f_fold_occs to use *)
  let get_bad : IOS.f_fold_occs = get_bad_occs m k int_f ~pk_f in

  (* get all occurrences *)
  let occs =
    IOS.find_all_occurrences ~mode:PTimeNoSI ~pp_descr:(Some pp_k)
      get_bad
      (TS.get_trace_hyps s) contx env (t :: m :: k.Name.args)
  in

  (* sort the occurrences: first the key occs, then the integrity occs *)
  let occs_key, occs_int =
    List.partition
      (fun x ->
         match IOS.EO.(x.eo_occ.SO.so_cnt) with
         | BadKey _ -> true
         | IntegrityMsg _ -> false)
      occs
  in
  let occs = occs_key @ occs_int in

  (* compute the formulas stating that one of the occs is a collision *)
  let phis = List.map (IOF.occurrence_formula ~negate:false) occs in

  (* finally generate all corresponding goals *)
  let g = TS.conclusion s in 
  let integrity_goals =
    List.map
      (fun phi -> TS.set_conclusion (mk_impl ~simpl:false phi g) s)
      phis
  in

  (* copied from old euf, handles the composition goals *)
  let tag_s =
    match Oracle.get_oracle int_f (TS.table s) with
    (* if the hash is not tagged, we don't create another goal. *)
    | None -> []
    | Some f ->
      (* else, we create a goal where m,sk satisfy the axiom *)
      let uvarm, uvarkey,f = match f with
        | Quant (ForAll,[uvarm;uvarkey],f) -> uvarm,uvarkey,f
        | _ -> assert false
      in

      match Vars.ty uvarm,Vars.ty uvarkey with
      | Type.(Message, Message) -> 
        let f = 
          Term.subst [
            ESubst (Term.mk_var uvarm,m);
            ESubst (Term.mk_var uvarkey, Term.mk_name k.symb k.args);]
            f 
        in
        [TS.set_conclusion
           (Term.mk_impl f (TS.conclusion s)) s]

      | _ -> assert false 
  in

  tag_s @ integrity_goals


(*------------------------------------------------------------------*)
let euf_tac args s =
  let hyp = match args with
    | [hyp] -> hyp
    | _ -> 
      hard_failure
        (Failure "euf requires one argument: hypothesis")
  in
  match TraceLT.convert_args s [hyp] (Args.Sort Args.String) with
  | Args.Arg (Args.String hyp) -> wrap_fail (euf hyp) s
  | _ -> bad_args ()

(*------------------------------------------------------------------*)
let () =
  T.register_general "euf"
    ~pq_sound:true
    (LowTactics.gentac_of_ttac_arg euf_tac)
